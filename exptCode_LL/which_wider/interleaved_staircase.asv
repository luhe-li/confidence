function [Resp, RT, updated_sig] = interleaved_staircase(i, Conditions, Order,...
    current_sig, inputResp, destinatedLoc_A, ScreenInfo, ExpInfo,...
    VSinfo, windowPtr)

%% generate standard stimulus

targetLoc = ScreenInfo.xmid; % present at the center
% sample target locations per frame



RNcoordinates = randn(2,1);
dots_targetLoc_coordinates = [targetLoc+(...
    ScreenInfo.px_per_cm.*VSinfo.SD_blob(i).*RNcoordinates(1,:));...
    ScreenInfo.liftingYaxis+(ScreenInfo.px_per_cm.*...
    VSinfo.SD_yaxis.*RNcoordinates(2,:))];









% randomly draw VSinfo.num_randomDots [x;y] coordinates based on the centroid
% first compute the location of the visual stimulus in pixels
loc_pixel = round(ExpInfo.randVisPixel(i));
targetLoc = ScreenInfo.xmid + loc_pixel;
RNcoordinates = randn(2,1);
dots_targetLoc_coordinates = [targetLoc+(...
    ScreenInfo.px_per_cm.*VSinfo.SD_blob(i).*RNcoordinates(1,:));...
    ScreenInfo.liftingYaxis+(ScreenInfo.px_per_cm.*...
    VSinfo.SD_yaxis.*RNcoordinates(2,:))];
while 1
    %randomly draw 10 (x,y) coordinates based on the centroid
    RNcoordinates = randn(2,1);
    new_dot_targetLoc_coordinates = [targetLoc+(...
        ScreenInfo.px_per_cm.*VSinfo.SD_blob(i).*RNcoordinates(1,:));...
        ScreenInfo.liftingYaxis+(ScreenInfo.px_per_cm.*...
        VSinfo.SD_yaxis.*RNcoordinates(2,:))];
    dots_targetLoc_coordinates = [dots_targetLoc_coordinates,new_dot_targetLoc_coordinates];
    %make sure the center of the 10 blobs are aligned with the
    %predetermined location of the test stimulus
    dots_targetLoc_coordinates_shifted = shiftDotClouds(...
        dots_targetLoc_coordinates,loc_pixel,ScreenInfo);
    
    %check if they are within the boundaries
    check_withinTheLimit = CheckWithinTheBoundaries(...
        dots_targetLoc_coordinates_shifted,VSinfo.boxSize,ScreenInfo);
    
    %if the generated dots are within boundaries, then pass the
    %coordinates to the function generateDotClouds that gives out the
    %image texture.
    if check_withinTheLimit == 1
        if size(dots_targetLoc_coordinates,2) == VSinfo.num_randomDots
            dotClouds_targetLoc = generateDotClouds(windowPtr,...
                dots_targetLoc_coordinates_shifted,VSinfo,ScreenInfo);
            break;
        end
    else
        dots_targetLoc_coordinates = dots_targetLoc_coordinates(:,1:end-1);
    end
end
Resp.vStimDotsCoor = dots_targetLoc_coordinates;




    %----------------------------------------------------------------------
    %-----------Calculate the coordinates of the target stimuli------------
    %----------------------------------------------------------------------
    Vloc_idx  = fix((Conditions+1)/2);
    Vloc      = VSinfo.locations_cm(Vloc_idx);
    targetLoc = round(ScreenInfo.xmid + ScreenInfo.px_per_cm.*Vloc);

    %Make visual stimuli
    blob_coordinates = [targetLoc, ScreenInfo.liftingYaxis];    
    dotCloud = generateOneBlob(windowPtr,blob_coordinates,VSinfo,ScreenInfo);

    %----------------------------------------------------------------------
    %--------------Move the motor to the correct location------------------
    %----------------------------------------------------------------------
    %display Mask Noise
    PsychPortAudio('FillBuffer', pahandle, AudInfo.MaskNoise);
    PsychPortAudio('Start', pahandle, 0, 0, 1);
    
    %calculate the wait time
    moving_steps = round((tan(deg2rad(destinatedLoc_A))-...
        tan(deg2rad(current_sig)))*ExpInfo.sittingDistance/3,2);    
    %move the speaker to the location we want 
    if moving_steps < 0 
        fprintf(motorArduino,['%c','%d'], ['p', trailSteps*abs(moving_steps)]);
    %when AuditoryLoc is negative, move to the left
    else
        fprintf(motorArduino,['%c','%d'], ['n', trailSteps*abs(moving_steps)]);
    end
    WaitSecs(AudInfo.waitTime);
    PsychPortAudio('Stop', pahandle);

    %----------------------------------------------------------------------
    %---------------------display audiovisual stimuli----------------------
    %----------------------------------------------------------------------
    %show fixation cross for 0.5 s and then a blank screen for 1 s
    Screen('FillRect', windowPtr,[255 255 255], [ScreenInfo.x1_lb,...
        ScreenInfo.y1_lb, ScreenInfo.x1_ub, ScreenInfo.y1_ub]);
    Screen('FillRect', windowPtr,[255 255 255], [ScreenInfo.x2_lb,...
        ScreenInfo.y2_lb, ScreenInfo.x2_ub, ScreenInfo.y2_ub]);
    Screen('Flip',windowPtr); WaitSecs(0.5);
    Screen('Flip',windowPtr); WaitSecs(1);
    
    if Order == 2 %present the V first
        for j = 1:VSinfo.numFrames 
            Screen('DrawTexture',windowPtr, dotCloud,[],[0,0,ScreenInfo.xaxis,...
                ScreenInfo.yaxis]);
            Screen('Flip',windowPtr);
        end     
        
        for k = 1:30 %500ms blank screen
            Screen('DrawTexture',windowPtr, VSinfo.blk_texture,[],...
                [0,0,ScreenInfo.xaxis, ScreenInfo.yaxis]);
            Screen('Flip',windowPtr);
        end

        %show fixation cross for 0.5 s and then a blank screen for 1 s
        Screen('FillRect', windowPtr,[255 255 255], [ScreenInfo.x1_lb,...
            ScreenInfo.y1_lb, ScreenInfo.x1_ub, ScreenInfo.y1_ub]);
        Screen('FillRect', windowPtr,[255 255 255], [ScreenInfo.x2_lb,...
            ScreenInfo.y2_lb, ScreenInfo.x2_ub, ScreenInfo.y2_ub]);
        Screen('Flip',windowPtr); WaitSecs(0.5);
        Screen('Flip',windowPtr); WaitSecs(1);
        
        PsychPortAudio('FillBuffer', pahandle, AudInfo.GaussianWhiteNoise);
        PsychPortAudio('Start', pahandle, 1, 0, 0);    
        WaitSecs(0.1);%the auditory stimulus will last for 100 ms
        PsychPortAudio('Stop', pahandle);
        
    else %present the A first
        PsychPortAudio('FillBuffer', pahandle, AudInfo.GaussianWhiteNoise);
        PsychPortAudio('Start', pahandle, 1, 0, 0);    
        WaitSecs(0.1);%the auditory stimulus will last for 100 ms
        PsychPortAudio('Stop', pahandle);
        
        for k = 1:30 %500ms blank screen
            Screen('DrawTexture',windowPtr, VSinfo.blk_texture,[],...
                [0,0,ScreenInfo.xaxis, ScreenInfo.yaxis]);
            Screen('Flip',windowPtr);
        end
        
        %show fixation cross for 0.5 s and then a blank screen for 1 s
        Screen('FillRect', windowPtr,[255 255 255], [ScreenInfo.x1_lb,...
            ScreenInfo.y1_lb, ScreenInfo.x1_ub, ScreenInfo.y1_ub]);
        Screen('FillRect', windowPtr,[255 255 255], [ScreenInfo.x2_lb,...
            ScreenInfo.y2_lb, ScreenInfo.x2_ub, ScreenInfo.y2_ub]);
        Screen('Flip',windowPtr); WaitSecs(0.5);
        Screen('Flip',windowPtr); WaitSecs(1);
        
        for j = 1:VSinfo.numFrames 
            %Screen('DrawDots', windowPtr, dots_standardLoc_coordinates,4,[250 250 250]);
            Screen('DrawTexture',windowPtr,dotCloud,[],[0,0,ScreenInfo.xaxis,...
                ScreenInfo.yaxis]);
            Screen('Flip',windowPtr);
        end 
    end
    
    %----------------------------------------------------------------------
    %---------------------Record and update responses----------------------
    %----------------------------------------------------------------------    
    %record response and RTs
    DrawFormattedText(windowPtr, 'Is the A to the left or right of the V?',...
        'center',ScreenInfo.yaxis-ScreenInfo.liftingYaxis-60,[255 255 255]);
    DrawFormattedText(windowPtr, 'Left: press 1',...
        'center',ScreenInfo.yaxis-ScreenInfo.liftingYaxis-30,[255 255 255]);
    DrawFormattedText(windowPtr, 'Right: press 2',...
        'center',ScreenInfo.yaxis-ScreenInfo.liftingYaxis,[255 255 255]);
    Screen('Flip',windowPtr); WaitSecs(0.1);  

    KbName('UnifyKeyNames'); tic
    while 1  
        % record response
        [~, keyCode, ~] = KbWait(-3);
        pressedKey = KbName(keyCode);
        RT = toc;
        %When space bar is pressed
        if strcmpi(pressedKey, '1') == 1 %1/1!
            Resp = -1; break;
        elseif strcmpi(pressedKey, '2') == 1 %2/2@
            Resp = 1; break;  
        end  
        WaitSecs(0.1);
    end
    Screen('Flip',windowPtr);
    WaitSecs(0.1);
    
    %----------------------------------------------------------------------
    %-------------Calculate the step size for the next trial---------------
    %----------------------------------------------------------------------     
    %find out the next distance
    updated_sig = FindNextDistance(AudInfo, Conditions, i, ...
        destinatedLoc_A, inputResp, Resp);   
    %no feedback 
end
    
